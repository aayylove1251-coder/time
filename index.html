import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

/* ---------- 時鐘 Canvas ---------- */
const clockCanvas = document.getElementById('clockCanvas');
const ctx = clockCanvas.getContext('2d');

function resizeClock() {
  clockCanvas.width = clockCanvas.clientWidth;
  clockCanvas.height = clockCanvas.clientHeight;
}
resizeClock();
window.addEventListener('resize', resizeClock);

function drawClock() {
  const w = clockCanvas.width;
  const h = clockCanvas.height;
  const r = Math.min(w, h) / 2 - 10;

  ctx.clearRect(0, 0, w, h);
  ctx.save();
  ctx.translate(w / 2, h / 2);

  ctx.strokeStyle = 'white';
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.arc(0, 0, r, 0, Math.PI * 2);
  ctx.stroke();

  const now = new Date();
  const sec = now.getSeconds();
  const min = now.getMinutes();
  const hr = now.getHours() % 12;

  function hand(angle, len, width) {
    ctx.save();
    ctx.rotate(angle);
    ctx.lineWidth = width;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(0, -len);
    ctx.stroke();
    ctx.restore();
  }

  hand((Math.PI / 6) * hr + (Math.PI / 360) * min, r * 0.5, 6);
  hand((Math.PI / 30) * min, r * 0.7, 4);
  hand((Math.PI / 30) * sec, r * 0.9, 2);

  ctx.restore();
  requestAnimationFrame(drawClock);
}
drawClock();

/* ---------- Three.js 3D ---------- */
const canvas = document.getElementById('modelCanvas');
const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(
  45,
  canvas.clientWidth / canvas.clientHeight,
  0.1,
  100
);
camera.position.set(0, 1.5, 3);

const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
renderer.setSize(canvas.clientWidth, canvas.clientHeight);
renderer.setPixelRatio(devicePixelRatio);

const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(3, 5, 3);
scene.add(light);
scene.add(new THREE.AmbientLight(0xffffff, 0.6));

const controls = new OrbitControls(camera, canvas);
controls.enableDamping = true;

let model;
const loader = new GLTFLoader();

document.getElementById('modelUpload').addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;

  document.getElementById('fileName').textContent = file.name;

  const url = URL.createObjectURL(file);
  loader.load(url, gltf => {
    if (model) scene.remove(model);
    model = gltf.scene;
    scene.add(model);
  });
});

function animate() {
  requestAnimationFrame(animate);
  if (model) model.rotation.y += 0.01;
  controls.update();
  renderer.render(scene, camera);
}
animate();


